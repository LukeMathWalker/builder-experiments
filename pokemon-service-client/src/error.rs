// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// Not authorized to access Pokémon storage.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotAuthorized {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotAuthorized {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotAuthorized");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NotAuthorized {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotAuthorized {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotAuthorized")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotAuthorized {}
/// See [`NotAuthorized`](crate::error::NotAuthorized).
pub mod not_authorized {

    /// A builder for [`NotAuthorized`](crate::error::NotAuthorized).
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NotAuthorized`](crate::error::NotAuthorized).
        pub fn build(self) -> crate::error::NotAuthorized {
            crate::error::NotAuthorized {
                message: self.message,
            }
        }
    }
}
impl NotAuthorized {
    /// Creates a new builder-style object to manufacture [`NotAuthorized`](crate::error::NotAuthorized).
    pub fn builder() -> crate::error::not_authorized::Builder {
        crate::error::not_authorized::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundError {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotFoundError {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundError [ResourceNotFoundException]")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundError {}
/// See [`ResourceNotFoundError`](crate::error::ResourceNotFoundError).
pub mod resource_not_found_error {

    /// A builder for [`ResourceNotFoundError`](crate::error::ResourceNotFoundError).
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundError`](crate::error::ResourceNotFoundError).
        pub fn build(self) -> crate::error::ResourceNotFoundError {
            crate::error::ResourceNotFoundError {
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundError {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundError`](crate::error::ResourceNotFoundError).
    pub fn builder() -> crate::error::resource_not_found_error::Builder {
        crate::error::resource_not_found_error::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ThrottlingError {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ThrottlingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ThrottlingError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ThrottlingError {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ThrottlingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ThrottlingError")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for ThrottlingError {}
/// See [`ThrottlingError`](crate::error::ThrottlingError).
pub mod throttling_error {

    /// A builder for [`ThrottlingError`](crate::error::ThrottlingError).
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ThrottlingError`](crate::error::ThrottlingError).
        pub fn build(self) -> crate::error::ThrottlingError {
            crate::error::ThrottlingError {
                message: self.message,
            }
        }
    }
}
impl ThrottlingError {
    /// Creates a new builder-style object to manufacture [`ThrottlingError`](crate::error::ThrottlingError).
    pub fn builder() -> crate::error::throttling_error::Builder {
        crate::error::throttling_error::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedRegionError {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub region: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl UnsupportedRegionError {
    #[allow(missing_docs)] // documentation missing in model
    pub fn region(&self) -> std::option::Option<&str> {
        self.region.as_deref()
    }
}
impl std::fmt::Debug for UnsupportedRegionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedRegionError");
        formatter.field("region", &self.region);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnsupportedRegionError {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedRegionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedRegionError")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedRegionError {}
/// See [`UnsupportedRegionError`](crate::error::UnsupportedRegionError).
pub mod unsupported_region_error {

    /// A builder for [`UnsupportedRegionError`](crate::error::UnsupportedRegionError).
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) region: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedRegionError`](crate::error::UnsupportedRegionError).
        pub fn build(self) -> crate::error::UnsupportedRegionError {
            crate::error::UnsupportedRegionError {
                region: self.region,
                message: self.message,
            }
        }
    }
}
impl UnsupportedRegionError {
    /// Creates a new builder-style object to manufacture [`UnsupportedRegionError`](crate::error::UnsupportedRegionError).
    pub fn builder() -> crate::error::unsupported_region_error::Builder {
        crate::error::unsupported_region_error::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MasterBallUnsuccessful {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MasterBallUnsuccessful {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MasterBallUnsuccessful");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MasterBallUnsuccessful {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MasterBallUnsuccessful {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MasterBallUnsuccessful")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for MasterBallUnsuccessful {}
/// See [`MasterBallUnsuccessful`](crate::error::MasterBallUnsuccessful).
pub mod master_ball_unsuccessful {

    /// A builder for [`MasterBallUnsuccessful`](crate::error::MasterBallUnsuccessful).
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MasterBallUnsuccessful`](crate::error::MasterBallUnsuccessful).
        pub fn build(self) -> crate::error::MasterBallUnsuccessful {
            crate::error::MasterBallUnsuccessful {
                message: self.message,
            }
        }
    }
}
impl MasterBallUnsuccessful {
    /// Creates a new builder-style object to manufacture [`MasterBallUnsuccessful`](crate::error::MasterBallUnsuccessful).
    pub fn builder() -> crate::error::master_ball_unsuccessful::Builder {
        crate::error::master_ball_unsuccessful::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidPokeballError {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub pokeball: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl InvalidPokeballError {
    #[allow(missing_docs)] // documentation missing in model
    pub fn pokeball(&self) -> std::option::Option<&str> {
        self.pokeball.as_deref()
    }
}
impl std::fmt::Debug for InvalidPokeballError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidPokeballError");
        formatter.field("pokeball", &self.pokeball);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidPokeballError {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPokeballError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPokeballError")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPokeballError {}
/// See [`InvalidPokeballError`](crate::error::InvalidPokeballError).
pub mod invalid_pokeball_error {

    /// A builder for [`InvalidPokeballError`](crate::error::InvalidPokeballError).
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pokeball: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn pokeball(mut self, input: impl Into<std::string::String>) -> Self {
            self.pokeball = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_pokeball(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.pokeball = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPokeballError`](crate::error::InvalidPokeballError).
        pub fn build(self) -> crate::error::InvalidPokeballError {
            crate::error::InvalidPokeballError {
                pokeball: self.pokeball,
                message: self.message,
            }
        }
    }
}
impl InvalidPokeballError {
    /// Creates a new builder-style object to manufacture [`InvalidPokeballError`](crate::error::InvalidPokeballError).
    pub fn builder() -> crate::error::invalid_pokeball_error::Builder {
        crate::error::invalid_pokeball_error::Builder::default()
    }
}

/// Error type for the `CheckHealth` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CheckHealthError {
    /// Kind of error that occurred.
    pub kind: CheckHealthErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CheckHealth` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CheckHealthErrorKind {
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CheckHealthError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CheckHealthErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CheckHealthError {
    fn code(&self) -> Option<&str> {
        CheckHealthError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CheckHealthError {
    /// Creates a new `CheckHealthError`.
    pub fn new(kind: CheckHealthErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CheckHealthError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CheckHealthErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CheckHealthError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CheckHealthErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for CheckHealthError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CheckHealthErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DoNothing` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DoNothingError {
    /// Kind of error that occurred.
    pub kind: DoNothingErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DoNothing` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DoNothingErrorKind {
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DoNothingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DoNothingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DoNothingError {
    fn code(&self) -> Option<&str> {
        DoNothingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DoNothingError {
    /// Creates a new `DoNothingError`.
    pub fn new(kind: DoNothingErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DoNothingError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DoNothingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DoNothingError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DoNothingErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DoNothingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DoNothingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetPokemonSpecies` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPokemonSpeciesError {
    /// Kind of error that occurred.
    pub kind: GetPokemonSpeciesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetPokemonSpecies` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPokemonSpeciesErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPokemonSpeciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPokemonSpeciesErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            GetPokemonSpeciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetPokemonSpeciesError {
    fn code(&self) -> Option<&str> {
        GetPokemonSpeciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPokemonSpeciesError {
    /// Creates a new `GetPokemonSpeciesError`.
    pub fn new(kind: GetPokemonSpeciesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetPokemonSpeciesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPokemonSpeciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetPokemonSpeciesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPokemonSpeciesErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetPokemonSpeciesErrorKind::ResourceNotFoundError`.
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            GetPokemonSpeciesErrorKind::ResourceNotFoundError(_)
        )
    }
}
impl std::error::Error for GetPokemonSpeciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPokemonSpeciesErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            GetPokemonSpeciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetServerStatistics` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetServerStatisticsError {
    /// Kind of error that occurred.
    pub kind: GetServerStatisticsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetServerStatistics` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetServerStatisticsErrorKind {
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetServerStatisticsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetServerStatisticsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetServerStatisticsError {
    fn code(&self) -> Option<&str> {
        GetServerStatisticsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetServerStatisticsError {
    /// Creates a new `GetServerStatisticsError`.
    pub fn new(kind: GetServerStatisticsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetServerStatisticsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetServerStatisticsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetServerStatisticsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetServerStatisticsErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for GetServerStatisticsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetServerStatisticsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CapturePokemon` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CapturePokemonError {
    /// Kind of error that occurred.
    pub kind: CapturePokemonErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CapturePokemon` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CapturePokemonErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    InvalidPokeballError(crate::error::InvalidPokeballError),
    #[allow(missing_docs)] // documentation missing in model
    MasterBallUnsuccessful(crate::error::MasterBallUnsuccessful),
    #[allow(missing_docs)] // documentation missing in model
    UnsupportedRegionError(crate::error::UnsupportedRegionError),
    #[allow(missing_docs)] // documentation missing in model
    ThrottlingError(crate::error::ThrottlingError),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CapturePokemonError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CapturePokemonErrorKind::InvalidPokeballError(_inner) => _inner.fmt(f),
            CapturePokemonErrorKind::MasterBallUnsuccessful(_inner) => _inner.fmt(f),
            CapturePokemonErrorKind::UnsupportedRegionError(_inner) => _inner.fmt(f),
            CapturePokemonErrorKind::ThrottlingError(_inner) => _inner.fmt(f),
            CapturePokemonErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CapturePokemonError {
    fn code(&self) -> Option<&str> {
        CapturePokemonError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CapturePokemonError {
    /// Creates a new `CapturePokemonError`.
    pub fn new(kind: CapturePokemonErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CapturePokemonError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CapturePokemonErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CapturePokemonError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CapturePokemonErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CapturePokemonErrorKind::InvalidPokeballError`.
    pub fn is_invalid_pokeball_error(&self) -> bool {
        matches!(&self.kind, CapturePokemonErrorKind::InvalidPokeballError(_))
    }
    /// Returns `true` if the error kind is `CapturePokemonErrorKind::MasterBallUnsuccessful`.
    pub fn is_master_ball_unsuccessful(&self) -> bool {
        matches!(
            &self.kind,
            CapturePokemonErrorKind::MasterBallUnsuccessful(_)
        )
    }
    /// Returns `true` if the error kind is `CapturePokemonErrorKind::UnsupportedRegionError`.
    pub fn is_unsupported_region_error(&self) -> bool {
        matches!(
            &self.kind,
            CapturePokemonErrorKind::UnsupportedRegionError(_)
        )
    }
    /// Returns `true` if the error kind is `CapturePokemonErrorKind::ThrottlingError`.
    pub fn is_throttling_error(&self) -> bool {
        matches!(&self.kind, CapturePokemonErrorKind::ThrottlingError(_))
    }
}
impl std::error::Error for CapturePokemonError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CapturePokemonErrorKind::InvalidPokeballError(_inner) => Some(_inner),
            CapturePokemonErrorKind::MasterBallUnsuccessful(_inner) => Some(_inner),
            CapturePokemonErrorKind::UnsupportedRegionError(_inner) => Some(_inner),
            CapturePokemonErrorKind::ThrottlingError(_inner) => Some(_inner),
            CapturePokemonErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetStorage` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetStorageError {
    /// Kind of error that occurred.
    pub kind: GetStorageErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetStorage` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetStorageErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// Not authorized to access Pokémon storage.
    NotAuthorized(crate::error::NotAuthorized),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetStorageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetStorageErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            GetStorageErrorKind::NotAuthorized(_inner) => _inner.fmt(f),
            GetStorageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetStorageError {
    fn code(&self) -> Option<&str> {
        GetStorageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetStorageError {
    /// Creates a new `GetStorageError`.
    pub fn new(kind: GetStorageErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetStorageError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetStorageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetStorageError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetStorageErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetStorageErrorKind::ResourceNotFoundError`.
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(&self.kind, GetStorageErrorKind::ResourceNotFoundError(_))
    }
    /// Returns `true` if the error kind is `GetStorageErrorKind::NotAuthorized`.
    pub fn is_not_authorized(&self) -> bool {
        matches!(&self.kind, GetStorageErrorKind::NotAuthorized(_))
    }
}
impl std::error::Error for GetStorageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetStorageErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            GetStorageErrorKind::NotAuthorized(_inner) => Some(_inner),
            GetStorageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `AttemptCapturingPokemonEvent` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AttemptCapturingPokemonEventError {
    /// Kind of error that occurred.
    pub kind: AttemptCapturingPokemonEventErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `AttemptCapturingPokemonEvent` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AttemptCapturingPokemonEventErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    MasterBallUnsuccessful(crate::error::MasterBallUnsuccessful),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AttemptCapturingPokemonEventError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AttemptCapturingPokemonEventErrorKind::MasterBallUnsuccessful(_inner) => _inner.fmt(f),
            AttemptCapturingPokemonEventErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AttemptCapturingPokemonEventError {
    fn code(&self) -> Option<&str> {
        AttemptCapturingPokemonEventError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AttemptCapturingPokemonEventError {
    /// Creates a new `AttemptCapturingPokemonEventError`.
    pub fn new(kind: AttemptCapturingPokemonEventErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `AttemptCapturingPokemonEventError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AttemptCapturingPokemonEventErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `AttemptCapturingPokemonEventError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AttemptCapturingPokemonEventErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `AttemptCapturingPokemonEventErrorKind::MasterBallUnsuccessful`.
    pub fn is_master_ball_unsuccessful(&self) -> bool {
        matches!(
            &self.kind,
            AttemptCapturingPokemonEventErrorKind::MasterBallUnsuccessful(_)
        )
    }
}
impl std::error::Error for AttemptCapturingPokemonEventError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AttemptCapturingPokemonEventErrorKind::MasterBallUnsuccessful(_inner) => Some(_inner),
            AttemptCapturingPokemonEventErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CapturePokemonEvents` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CapturePokemonEventsError {
    /// Kind of error that occurred.
    pub kind: CapturePokemonEventsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CapturePokemonEvents` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CapturePokemonEventsErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    InvalidPokeballError(crate::error::InvalidPokeballError),
    #[allow(missing_docs)] // documentation missing in model
    ThrottlingError(crate::error::ThrottlingError),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CapturePokemonEventsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CapturePokemonEventsErrorKind::InvalidPokeballError(_inner) => _inner.fmt(f),
            CapturePokemonEventsErrorKind::ThrottlingError(_inner) => _inner.fmt(f),
            CapturePokemonEventsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CapturePokemonEventsError {
    fn code(&self) -> Option<&str> {
        CapturePokemonEventsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CapturePokemonEventsError {
    /// Creates a new `CapturePokemonEventsError`.
    pub fn new(kind: CapturePokemonEventsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CapturePokemonEventsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CapturePokemonEventsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CapturePokemonEventsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CapturePokemonEventsErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CapturePokemonEventsErrorKind::InvalidPokeballError`.
    pub fn is_invalid_pokeball_error(&self) -> bool {
        matches!(
            &self.kind,
            CapturePokemonEventsErrorKind::InvalidPokeballError(_)
        )
    }
    /// Returns `true` if the error kind is `CapturePokemonEventsErrorKind::ThrottlingError`.
    pub fn is_throttling_error(&self) -> bool {
        matches!(
            &self.kind,
            CapturePokemonEventsErrorKind::ThrottlingError(_)
        )
    }
}
impl std::error::Error for CapturePokemonEventsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CapturePokemonEventsErrorKind::InvalidPokeballError(_inner) => Some(_inner),
            CapturePokemonEventsErrorKind::ThrottlingError(_inner) => Some(_inner),
            CapturePokemonEventsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}
