// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[cfg(test)]
#[allow(dead_code)]
pub(crate) mod protocol_test_helper {
    use tower::Service as _;

    pub(crate) type Fun<Input, Output> =
        fn(Input) -> std::pin::Pin<Box<dyn std::future::Future<Output = Output> + Send>>;

    type RegistryBuilder = crate::operation_registry::OperationRegistryBuilder<
        hyper::Body,
        Fun<crate::input::CheckHealthInput, crate::output::CheckHealthOutput>,
        (),
        Fun<crate::input::DoNothingInput, crate::output::DoNothingOutput>,
        (),
        Fun<
            crate::input::GetPokemonSpeciesInput,
            Result<crate::output::GetPokemonSpeciesOutput, crate::error::GetPokemonSpeciesError>,
        >,
        (),
        Fun<crate::input::GetServerStatisticsInput, crate::output::GetServerStatisticsOutput>,
        (),
        Fun<
            crate::input::CapturePokemonInput,
            Result<crate::output::CapturePokemonOutput, crate::error::CapturePokemonError>,
        >,
        (),
        Fun<
            crate::input::GetStorageInput,
            Result<crate::output::GetStorageOutput, crate::error::GetStorageError>,
        >,
        (),
    >;

    fn create_operation_registry_builder() -> RegistryBuilder {
        crate::operation_registry::OperationRegistryBuilder::default()
            .check_health(
                (|_| Box::pin(async { todo!() }))
                    as Fun<crate::input::CheckHealthInput, crate::output::CheckHealthOutput>,
            )
            .do_nothing(
                (|_| Box::pin(async { todo!() }))
                    as Fun<crate::input::DoNothingInput, crate::output::DoNothingOutput>,
            )
            .get_pokemon_species(
                (|_| Box::pin(async { todo!() }))
                    as Fun<
                        crate::input::GetPokemonSpeciesInput,
                        Result<
                            crate::output::GetPokemonSpeciesOutput,
                            crate::error::GetPokemonSpeciesError,
                        >,
                    >,
            )
            .get_server_statistics(
                (|_| Box::pin(async { todo!() }))
                    as Fun<
                        crate::input::GetServerStatisticsInput,
                        crate::output::GetServerStatisticsOutput,
                    >,
            )
            .capture_pokemon(
                (|_| Box::pin(async { todo!() }))
                    as Fun<
                        crate::input::CapturePokemonInput,
                        Result<
                            crate::output::CapturePokemonOutput,
                            crate::error::CapturePokemonError,
                        >,
                    >,
            )
            .get_storage(
                (|_| Box::pin(async { todo!() }))
                    as Fun<
                        crate::input::GetStorageInput,
                        Result<crate::output::GetStorageOutput, crate::error::GetStorageError>,
                    >,
            )
    }

    /// The operation full name is a concatenation of `<operation namespace>.<operation name>`.
    pub(crate) async fn build_router_and_make_request(
        http_request: http::request::Request<aws_smithy_http_server::body::Body>,
        operation_full_name: &str,
        f: &dyn Fn(RegistryBuilder) -> RegistryBuilder,
    ) {
        let mut router: aws_smithy_http_server::routing::Router =
            f(create_operation_registry_builder())
                .build()
                .expect("unable to build operation registry")
                .into();
        let http_response = router
            .call(http_request)
            .await
            .expect("unable to make an HTTP request");
        let operation_extension = http_response
            .extensions()
            .get::<aws_smithy_http_server::extension::OperationExtension>()
            .expect("extension `OperationExtension` not found");
        pretty_assertions::assert_eq!(operation_extension.absolute(), operation_full_name);
    }
}
#[derive(Debug)]
pub(crate) struct CheckHealthOperationInputWrapper(crate::input::CheckHealthInput);
impl CheckHealthOperationInputWrapper {
    pub async fn from_request<B>(
        req: &mut aws_smithy_http_server::request::RequestParts<B>,
    ) -> Result<Self, aws_smithy_http_server::runtime_error::RuntimeError>
    where
        B: aws_smithy_http_server::body::HttpBody + Send,
        B::Data: Send,
        aws_smithy_http_server::rejection::RequestRejection:
            From<<B as aws_smithy_http_server::body::HttpBody>::Error>,
    {
        if !aws_smithy_http_server::protocols::accept_header_classifier(req, "application/json") {
            return Err(aws_smithy_http_server::runtime_error::RuntimeError::NotAcceptable);
        }

        crate::operation_deser::parse_check_health_request(req)
            .await
            .map(CheckHealthOperationInputWrapper)
            .map_err(Into::into)
    }
}

impl<B>
    aws_smithy_http_server::request::FromRequest<
        aws_smithy_http_server::proto::rest_json_1::AwsRestJson1,
        B,
    > for crate::input::CheckHealthInput
where
    B: aws_smithy_http_server::body::HttpBody + Send,
    B: 'static,

    B::Data: Send,
    aws_smithy_http_server::rejection::RequestRejection:
        From<<B as aws_smithy_http_server::body::HttpBody>::Error>,
{
    type Rejection = aws_smithy_http_server::runtime_error::RuntimeError;
    type Future =
        std::pin::Pin<Box<dyn std::future::Future<Output = Result<Self, Self::Rejection>> + Send>>;

    fn from_request(request: http::Request<B>) -> Self::Future {
        let fut = async move {
            let mut request_parts = aws_smithy_http_server::request::RequestParts::new(request);
            CheckHealthOperationInputWrapper::from_request(&mut request_parts)
                .await
                .map(|x| x.0)
        };
        Box::pin(fut)
    }
}
pub(crate) struct CheckHealthOperationOutputWrapper(crate::output::CheckHealthOutput);

impl CheckHealthOperationOutputWrapper {
    pub fn into_response(self) -> aws_smithy_http_server::response::Response {
        match crate::operation_ser::serialize_check_health_response(self.0) {
            Ok(response) => response,
            Err(e) => aws_smithy_http_server::response::IntoResponse::<
                aws_smithy_http_server::proto::rest_json_1::AwsRestJson1,
            >::into_response(
                aws_smithy_http_server::runtime_error::RuntimeError::from(e)
            ),
        }
    }
}

impl
    aws_smithy_http_server::response::IntoResponse<
        aws_smithy_http_server::proto::rest_json_1::AwsRestJson1,
    > for crate::output::CheckHealthOutput
{
    fn into_response(self) -> aws_smithy_http_server::response::Response {
        CheckHealthOperationOutputWrapper(self).into_response()
    }
}
impl std::convert::From<crate::output::CheckHealthOutput> for CheckHealthOperationOutputWrapper {
    fn from(o: crate::output::CheckHealthOutput) -> Self {
        Self(o)
    }
}
impl std::convert::From<CheckHealthOperationInputWrapper> for crate::input::CheckHealthInput {
    fn from(i: CheckHealthOperationInputWrapper) -> Self {
        i.0
    }
}
#[derive(Debug)]
pub(crate) struct DoNothingOperationInputWrapper(crate::input::DoNothingInput);
impl DoNothingOperationInputWrapper {
    pub async fn from_request<B>(
        req: &mut aws_smithy_http_server::request::RequestParts<B>,
    ) -> Result<Self, aws_smithy_http_server::runtime_error::RuntimeError>
    where
        B: aws_smithy_http_server::body::HttpBody + Send,
        B::Data: Send,
        aws_smithy_http_server::rejection::RequestRejection:
            From<<B as aws_smithy_http_server::body::HttpBody>::Error>,
    {
        if !aws_smithy_http_server::protocols::accept_header_classifier(req, "application/json") {
            return Err(aws_smithy_http_server::runtime_error::RuntimeError::NotAcceptable);
        }

        crate::operation_deser::parse_do_nothing_request(req)
            .await
            .map(DoNothingOperationInputWrapper)
            .map_err(Into::into)
    }
}

impl<B>
    aws_smithy_http_server::request::FromRequest<
        aws_smithy_http_server::proto::rest_json_1::AwsRestJson1,
        B,
    > for crate::input::DoNothingInput
where
    B: aws_smithy_http_server::body::HttpBody + Send,
    B: 'static,

    B::Data: Send,
    aws_smithy_http_server::rejection::RequestRejection:
        From<<B as aws_smithy_http_server::body::HttpBody>::Error>,
{
    type Rejection = aws_smithy_http_server::runtime_error::RuntimeError;
    type Future =
        std::pin::Pin<Box<dyn std::future::Future<Output = Result<Self, Self::Rejection>> + Send>>;

    fn from_request(request: http::Request<B>) -> Self::Future {
        let fut = async move {
            let mut request_parts = aws_smithy_http_server::request::RequestParts::new(request);
            DoNothingOperationInputWrapper::from_request(&mut request_parts)
                .await
                .map(|x| x.0)
        };
        Box::pin(fut)
    }
}
pub(crate) struct DoNothingOperationOutputWrapper(crate::output::DoNothingOutput);

impl DoNothingOperationOutputWrapper {
    pub fn into_response(self) -> aws_smithy_http_server::response::Response {
        match crate::operation_ser::serialize_do_nothing_response(self.0) {
            Ok(response) => response,
            Err(e) => aws_smithy_http_server::response::IntoResponse::<
                aws_smithy_http_server::proto::rest_json_1::AwsRestJson1,
            >::into_response(
                aws_smithy_http_server::runtime_error::RuntimeError::from(e)
            ),
        }
    }
}

impl
    aws_smithy_http_server::response::IntoResponse<
        aws_smithy_http_server::proto::rest_json_1::AwsRestJson1,
    > for crate::output::DoNothingOutput
{
    fn into_response(self) -> aws_smithy_http_server::response::Response {
        DoNothingOperationOutputWrapper(self).into_response()
    }
}
impl std::convert::From<crate::output::DoNothingOutput> for DoNothingOperationOutputWrapper {
    fn from(o: crate::output::DoNothingOutput) -> Self {
        Self(o)
    }
}
impl std::convert::From<DoNothingOperationInputWrapper> for crate::input::DoNothingInput {
    fn from(i: DoNothingOperationInputWrapper) -> Self {
        i.0
    }
}
#[derive(Debug)]
pub(crate) struct GetPokemonSpeciesOperationInputWrapper(crate::input::GetPokemonSpeciesInput);
impl GetPokemonSpeciesOperationInputWrapper {
    pub async fn from_request<B>(
        req: &mut aws_smithy_http_server::request::RequestParts<B>,
    ) -> Result<Self, aws_smithy_http_server::runtime_error::RuntimeError>
    where
        B: aws_smithy_http_server::body::HttpBody + Send,
        B::Data: Send,
        aws_smithy_http_server::rejection::RequestRejection:
            From<<B as aws_smithy_http_server::body::HttpBody>::Error>,
    {
        if !aws_smithy_http_server::protocols::accept_header_classifier(req, "application/json") {
            return Err(aws_smithy_http_server::runtime_error::RuntimeError::NotAcceptable);
        }

        crate::operation_deser::parse_get_pokemon_species_request(req)
            .await
            .map(GetPokemonSpeciesOperationInputWrapper)
            .map_err(Into::into)
    }
}

impl<B>
    aws_smithy_http_server::request::FromRequest<
        aws_smithy_http_server::proto::rest_json_1::AwsRestJson1,
        B,
    > for crate::input::GetPokemonSpeciesInput
where
    B: aws_smithy_http_server::body::HttpBody + Send,
    B: 'static,

    B::Data: Send,
    aws_smithy_http_server::rejection::RequestRejection:
        From<<B as aws_smithy_http_server::body::HttpBody>::Error>,
{
    type Rejection = aws_smithy_http_server::runtime_error::RuntimeError;
    type Future =
        std::pin::Pin<Box<dyn std::future::Future<Output = Result<Self, Self::Rejection>> + Send>>;

    fn from_request(request: http::Request<B>) -> Self::Future {
        let fut = async move {
            let mut request_parts = aws_smithy_http_server::request::RequestParts::new(request);
            GetPokemonSpeciesOperationInputWrapper::from_request(&mut request_parts)
                .await
                .map(|x| x.0)
        };
        Box::pin(fut)
    }
}
pub(crate) enum GetPokemonSpeciesOperationOutputWrapper {
    Output(crate::output::GetPokemonSpeciesOutput),
    Error(crate::error::GetPokemonSpeciesError),
}

impl GetPokemonSpeciesOperationOutputWrapper {
    pub fn into_response(self) -> aws_smithy_http_server::response::Response {
        match self {
            Self::Output(o) => {
                match crate::operation_ser::serialize_get_pokemon_species_response(o) {
                    Ok(response) => response,
                    Err(e) => aws_smithy_http_server::response::IntoResponse::<
                        aws_smithy_http_server::proto::rest_json_1::AwsRestJson1,
                    >::into_response(
                        aws_smithy_http_server::runtime_error::RuntimeError::from(e)
                    ),
                }
            }
            Self::Error(err) => {
                match crate::operation_ser::serialize_get_pokemon_species_error(&err) {
                    Ok(mut response) => {
                        response.extensions_mut().insert(
                            aws_smithy_http_server::extension::ModeledErrorExtension::new(
                                err.name(),
                            ),
                        );
                        response
                    }
                    Err(e) => aws_smithy_http_server::response::IntoResponse::<
                        aws_smithy_http_server::proto::rest_json_1::AwsRestJson1,
                    >::into_response(
                        aws_smithy_http_server::runtime_error::RuntimeError::from(e)
                    ),
                }
            }
        }
    }
}

impl
    aws_smithy_http_server::response::IntoResponse<
        aws_smithy_http_server::proto::rest_json_1::AwsRestJson1,
    > for crate::output::GetPokemonSpeciesOutput
{
    fn into_response(self) -> aws_smithy_http_server::response::Response {
        GetPokemonSpeciesOperationOutputWrapper::Output(self).into_response()
    }
}

impl
    aws_smithy_http_server::response::IntoResponse<
        aws_smithy_http_server::proto::rest_json_1::AwsRestJson1,
    > for crate::error::GetPokemonSpeciesError
{
    fn into_response(self) -> aws_smithy_http_server::response::Response {
        GetPokemonSpeciesOperationOutputWrapper::Error(self).into_response()
    }
}
impl
    std::convert::From<
        Result<crate::output::GetPokemonSpeciesOutput, crate::error::GetPokemonSpeciesError>,
    > for GetPokemonSpeciesOperationOutputWrapper
{
    fn from(
        res: Result<crate::output::GetPokemonSpeciesOutput, crate::error::GetPokemonSpeciesError>,
    ) -> Self {
        match res {
            Ok(v) => Self::Output(v),
            Err(e) => Self::Error(e),
        }
    }
}
impl std::convert::From<GetPokemonSpeciesOperationInputWrapper>
    for crate::input::GetPokemonSpeciesInput
{
    fn from(i: GetPokemonSpeciesOperationInputWrapper) -> Self {
        i.0
    }
}
#[derive(Debug)]
pub(crate) struct GetServerStatisticsOperationInputWrapper(crate::input::GetServerStatisticsInput);
impl GetServerStatisticsOperationInputWrapper {
    pub async fn from_request<B>(
        req: &mut aws_smithy_http_server::request::RequestParts<B>,
    ) -> Result<Self, aws_smithy_http_server::runtime_error::RuntimeError>
    where
        B: aws_smithy_http_server::body::HttpBody + Send,
        B::Data: Send,
        aws_smithy_http_server::rejection::RequestRejection:
            From<<B as aws_smithy_http_server::body::HttpBody>::Error>,
    {
        if !aws_smithy_http_server::protocols::accept_header_classifier(req, "application/json") {
            return Err(aws_smithy_http_server::runtime_error::RuntimeError::NotAcceptable);
        }

        crate::operation_deser::parse_get_server_statistics_request(req)
            .await
            .map(GetServerStatisticsOperationInputWrapper)
            .map_err(Into::into)
    }
}

impl<B>
    aws_smithy_http_server::request::FromRequest<
        aws_smithy_http_server::proto::rest_json_1::AwsRestJson1,
        B,
    > for crate::input::GetServerStatisticsInput
where
    B: aws_smithy_http_server::body::HttpBody + Send,
    B: 'static,

    B::Data: Send,
    aws_smithy_http_server::rejection::RequestRejection:
        From<<B as aws_smithy_http_server::body::HttpBody>::Error>,
{
    type Rejection = aws_smithy_http_server::runtime_error::RuntimeError;
    type Future =
        std::pin::Pin<Box<dyn std::future::Future<Output = Result<Self, Self::Rejection>> + Send>>;

    fn from_request(request: http::Request<B>) -> Self::Future {
        let fut = async move {
            let mut request_parts = aws_smithy_http_server::request::RequestParts::new(request);
            GetServerStatisticsOperationInputWrapper::from_request(&mut request_parts)
                .await
                .map(|x| x.0)
        };
        Box::pin(fut)
    }
}
pub(crate) struct GetServerStatisticsOperationOutputWrapper(
    crate::output::GetServerStatisticsOutput,
);

impl GetServerStatisticsOperationOutputWrapper {
    pub fn into_response(self) -> aws_smithy_http_server::response::Response {
        match crate::operation_ser::serialize_get_server_statistics_response(self.0) {
            Ok(response) => response,
            Err(e) => aws_smithy_http_server::response::IntoResponse::<
                aws_smithy_http_server::proto::rest_json_1::AwsRestJson1,
            >::into_response(
                aws_smithy_http_server::runtime_error::RuntimeError::from(e)
            ),
        }
    }
}

impl
    aws_smithy_http_server::response::IntoResponse<
        aws_smithy_http_server::proto::rest_json_1::AwsRestJson1,
    > for crate::output::GetServerStatisticsOutput
{
    fn into_response(self) -> aws_smithy_http_server::response::Response {
        GetServerStatisticsOperationOutputWrapper(self).into_response()
    }
}
impl std::convert::From<crate::output::GetServerStatisticsOutput>
    for GetServerStatisticsOperationOutputWrapper
{
    fn from(o: crate::output::GetServerStatisticsOutput) -> Self {
        Self(o)
    }
}
impl std::convert::From<GetServerStatisticsOperationInputWrapper>
    for crate::input::GetServerStatisticsInput
{
    fn from(i: GetServerStatisticsOperationInputWrapper) -> Self {
        i.0
    }
}
#[derive(Debug)]
pub(crate) struct CapturePokemonOperationInputWrapper(crate::input::CapturePokemonInput);
impl CapturePokemonOperationInputWrapper {
    pub async fn from_request<B>(
        req: &mut aws_smithy_http_server::request::RequestParts<B>,
    ) -> Result<Self, aws_smithy_http_server::runtime_error::RuntimeError>
    where
        B: aws_smithy_http_server::body::HttpBody + Send,
        B: Into<aws_smithy_http::byte_stream::ByteStream>,
        B::Data: Send,
        aws_smithy_http_server::rejection::RequestRejection:
            From<<B as aws_smithy_http_server::body::HttpBody>::Error>,
    {
        if !aws_smithy_http_server::protocols::accept_header_classifier(
            req,
            "application/vnd.amazon.eventstream",
        ) {
            return Err(aws_smithy_http_server::runtime_error::RuntimeError::NotAcceptable);
        }
        if aws_smithy_http_server::protocols::content_type_header_classifier(
            req,
            Some("application/vnd.amazon.eventstream"),
        )
        .is_err()
        {
            return Err(aws_smithy_http_server::runtime_error::RuntimeError::UnsupportedMediaType);
        }
        crate::operation_deser::parse_capture_pokemon_request(req)
            .await
            .map(CapturePokemonOperationInputWrapper)
            .map_err(Into::into)
    }
}

impl<B>
    aws_smithy_http_server::request::FromRequest<
        aws_smithy_http_server::proto::rest_json_1::AwsRestJson1,
        B,
    > for crate::input::CapturePokemonInput
where
    B: aws_smithy_http_server::body::HttpBody + Send,
    B: 'static,

    B: Into<aws_smithy_http::byte_stream::ByteStream>,
    B::Data: Send,
    aws_smithy_http_server::rejection::RequestRejection:
        From<<B as aws_smithy_http_server::body::HttpBody>::Error>,
{
    type Rejection = aws_smithy_http_server::runtime_error::RuntimeError;
    type Future =
        std::pin::Pin<Box<dyn std::future::Future<Output = Result<Self, Self::Rejection>> + Send>>;

    fn from_request(request: http::Request<B>) -> Self::Future {
        let fut = async move {
            let mut request_parts = aws_smithy_http_server::request::RequestParts::new(request);
            CapturePokemonOperationInputWrapper::from_request(&mut request_parts)
                .await
                .map(|x| x.0)
        };
        Box::pin(fut)
    }
}
pub(crate) enum CapturePokemonOperationOutputWrapper {
    Output(crate::output::CapturePokemonOutput),
    Error(crate::error::CapturePokemonError),
}

impl CapturePokemonOperationOutputWrapper {
    pub fn into_response(self) -> aws_smithy_http_server::response::Response {
        match self {
            Self::Output(o) => match crate::operation_ser::serialize_capture_pokemon_response(o) {
                Ok(response) => response,
                Err(e) => aws_smithy_http_server::response::IntoResponse::<
                    aws_smithy_http_server::proto::rest_json_1::AwsRestJson1,
                >::into_response(
                    aws_smithy_http_server::runtime_error::RuntimeError::from(e)
                ),
            },
            Self::Error(err) => match crate::operation_ser::serialize_capture_pokemon_error(&err) {
                Ok(mut response) => {
                    response.extensions_mut().insert(
                        aws_smithy_http_server::extension::ModeledErrorExtension::new(err.name()),
                    );
                    response
                }
                Err(e) => aws_smithy_http_server::response::IntoResponse::<
                    aws_smithy_http_server::proto::rest_json_1::AwsRestJson1,
                >::into_response(
                    aws_smithy_http_server::runtime_error::RuntimeError::from(e)
                ),
            },
        }
    }
}

impl
    aws_smithy_http_server::response::IntoResponse<
        aws_smithy_http_server::proto::rest_json_1::AwsRestJson1,
    > for crate::output::CapturePokemonOutput
{
    fn into_response(self) -> aws_smithy_http_server::response::Response {
        CapturePokemonOperationOutputWrapper::Output(self).into_response()
    }
}

impl
    aws_smithy_http_server::response::IntoResponse<
        aws_smithy_http_server::proto::rest_json_1::AwsRestJson1,
    > for crate::error::CapturePokemonError
{
    fn into_response(self) -> aws_smithy_http_server::response::Response {
        CapturePokemonOperationOutputWrapper::Error(self).into_response()
    }
}
impl
    std::convert::From<
        Result<crate::output::CapturePokemonOutput, crate::error::CapturePokemonError>,
    > for CapturePokemonOperationOutputWrapper
{
    fn from(
        res: Result<crate::output::CapturePokemonOutput, crate::error::CapturePokemonError>,
    ) -> Self {
        match res {
            Ok(v) => Self::Output(v),
            Err(e) => Self::Error(e),
        }
    }
}
impl std::convert::From<CapturePokemonOperationInputWrapper> for crate::input::CapturePokemonInput {
    fn from(i: CapturePokemonOperationInputWrapper) -> Self {
        i.0
    }
}
#[derive(Debug)]
pub(crate) struct GetStorageOperationInputWrapper(crate::input::GetStorageInput);
impl GetStorageOperationInputWrapper {
    pub async fn from_request<B>(
        req: &mut aws_smithy_http_server::request::RequestParts<B>,
    ) -> Result<Self, aws_smithy_http_server::runtime_error::RuntimeError>
    where
        B: aws_smithy_http_server::body::HttpBody + Send,
        B::Data: Send,
        aws_smithy_http_server::rejection::RequestRejection:
            From<<B as aws_smithy_http_server::body::HttpBody>::Error>,
    {
        if !aws_smithy_http_server::protocols::accept_header_classifier(req, "application/json") {
            return Err(aws_smithy_http_server::runtime_error::RuntimeError::NotAcceptable);
        }

        crate::operation_deser::parse_get_storage_request(req)
            .await
            .map(GetStorageOperationInputWrapper)
            .map_err(Into::into)
    }
}

impl<B>
    aws_smithy_http_server::request::FromRequest<
        aws_smithy_http_server::proto::rest_json_1::AwsRestJson1,
        B,
    > for crate::input::GetStorageInput
where
    B: aws_smithy_http_server::body::HttpBody + Send,
    B: 'static,

    B::Data: Send,
    aws_smithy_http_server::rejection::RequestRejection:
        From<<B as aws_smithy_http_server::body::HttpBody>::Error>,
{
    type Rejection = aws_smithy_http_server::runtime_error::RuntimeError;
    type Future =
        std::pin::Pin<Box<dyn std::future::Future<Output = Result<Self, Self::Rejection>> + Send>>;

    fn from_request(request: http::Request<B>) -> Self::Future {
        let fut = async move {
            let mut request_parts = aws_smithy_http_server::request::RequestParts::new(request);
            GetStorageOperationInputWrapper::from_request(&mut request_parts)
                .await
                .map(|x| x.0)
        };
        Box::pin(fut)
    }
}
pub(crate) enum GetStorageOperationOutputWrapper {
    Output(crate::output::GetStorageOutput),
    Error(crate::error::GetStorageError),
}

impl GetStorageOperationOutputWrapper {
    pub fn into_response(self) -> aws_smithy_http_server::response::Response {
        match self {
            Self::Output(o) => match crate::operation_ser::serialize_get_storage_response(o) {
                Ok(response) => response,
                Err(e) => aws_smithy_http_server::response::IntoResponse::<
                    aws_smithy_http_server::proto::rest_json_1::AwsRestJson1,
                >::into_response(
                    aws_smithy_http_server::runtime_error::RuntimeError::from(e)
                ),
            },
            Self::Error(err) => match crate::operation_ser::serialize_get_storage_error(&err) {
                Ok(mut response) => {
                    response.extensions_mut().insert(
                        aws_smithy_http_server::extension::ModeledErrorExtension::new(err.name()),
                    );
                    response
                }
                Err(e) => aws_smithy_http_server::response::IntoResponse::<
                    aws_smithy_http_server::proto::rest_json_1::AwsRestJson1,
                >::into_response(
                    aws_smithy_http_server::runtime_error::RuntimeError::from(e)
                ),
            },
        }
    }
}

impl
    aws_smithy_http_server::response::IntoResponse<
        aws_smithy_http_server::proto::rest_json_1::AwsRestJson1,
    > for crate::output::GetStorageOutput
{
    fn into_response(self) -> aws_smithy_http_server::response::Response {
        GetStorageOperationOutputWrapper::Output(self).into_response()
    }
}

impl
    aws_smithy_http_server::response::IntoResponse<
        aws_smithy_http_server::proto::rest_json_1::AwsRestJson1,
    > for crate::error::GetStorageError
{
    fn into_response(self) -> aws_smithy_http_server::response::Response {
        GetStorageOperationOutputWrapper::Error(self).into_response()
    }
}
impl std::convert::From<Result<crate::output::GetStorageOutput, crate::error::GetStorageError>>
    for GetStorageOperationOutputWrapper
{
    fn from(res: Result<crate::output::GetStorageOutput, crate::error::GetStorageError>) -> Self {
        match res {
            Ok(v) => Self::Output(v),
            Err(e) => Self::Error(e),
        }
    }
}
impl std::convert::From<GetStorageOperationInputWrapper> for crate::input::GetStorageInput {
    fn from(i: GetStorageOperationInputWrapper) -> Self {
        i.0
    }
}
