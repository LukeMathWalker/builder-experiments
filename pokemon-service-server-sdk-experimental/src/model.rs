// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FlavorText {
    /// The localized flavor text for an API resource in a specific language.
    #[doc(hidden)]
    pub flavor_text: std::string::String,
    /// The language this name is in.
    #[doc(hidden)]
    pub language: crate::model::Language,
}
impl FlavorText {
    /// The localized flavor text for an API resource in a specific language.
    pub fn flavor_text(&self) -> &str {
        use std::ops::Deref;
        self.flavor_text.deref()
    }
    /// The language this name is in.
    pub fn language(&self) -> &crate::model::Language {
        &self.language
    }
}
impl std::fmt::Debug for FlavorText {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FlavorText");
        formatter.field("flavor_text", &self.flavor_text);
        formatter.field("language", &self.language);
        formatter.finish()
    }
}
/// See [`FlavorText`](crate::model::FlavorText).
pub mod flavor_text {

    /// A builder for [`FlavorText`](crate::model::FlavorText).
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) flavor_text: std::option::Option<std::string::String>,
        pub(crate) language: std::option::Option<crate::model::Language>,
    }
    impl Builder {
        /// The localized flavor text for an API resource in a specific language.
        pub fn flavor_text(mut self, input: impl Into<std::string::String>) -> Self {
            self.flavor_text = Some(input.into());
            self
        }
        /// The localized flavor text for an API resource in a specific language.
        pub fn set_flavor_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.flavor_text = input;
            self
        }
        /// The language this name is in.
        pub fn language(mut self, input: crate::model::Language) -> Self {
            self.language = Some(input);
            self
        }
        /// The language this name is in.
        pub fn set_language(mut self, input: std::option::Option<crate::model::Language>) -> Self {
            self.language = input;
            self
        }
        /// Consumes the builder and constructs a [`FlavorText`](crate::model::FlavorText).
        pub fn build(
            self,
        ) -> Result<crate::model::FlavorText, aws_smithy_http::operation::BuildError> {
            Ok(
                crate::model::FlavorText {
                    flavor_text: self.flavor_text
                        .unwrap_or_default()
                    ,
                    language: self.language
                        .ok_or(
                            aws_smithy_http::operation::BuildError::MissingField { field: "language", details: "language was not specified but it is required when building FlavorText" }
                        )?
                    ,
                }
            )
        }
    }
}
impl FlavorText {
    /// Creates a new builder-style object to manufacture [`FlavorText`](crate::model::FlavorText).
    pub fn builder() -> crate::model::flavor_text::Builder {
        crate::model::flavor_text::Builder::default()
    }
}

/// Supported languages for FlavorText entries.
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Language {
    /// American English.
    English,
    /// Español.
    Spanish,
    /// Italiano.
    Italian,
    /// 日本語。
    Japanese,
}
#[derive(Debug, PartialEq, Eq, Hash)]
pub struct LanguageUnknownVariantError(String);
impl std::convert::TryFrom<&str> for Language {
    type Error = LanguageUnknownVariantError;
    fn try_from(s: &str) -> Result<Self, <Language as std::convert::TryFrom<&str>>::Error> {
        match s {
            "en" => Ok(Language::English),
            "es" => Ok(Language::Spanish),
            "it" => Ok(Language::Italian),
            "jp" => Ok(Language::Japanese),
            _ => Err(LanguageUnknownVariantError(s.to_owned())),
        }
    }
}
impl std::convert::From<LanguageUnknownVariantError>
    for aws_smithy_http_server::rejection::RequestRejection
{
    fn from(e: LanguageUnknownVariantError) -> Self {
        Self::EnumVariantNotFound(Box::new(e))
    }
}
impl std::error::Error for LanguageUnknownVariantError {}
impl std::fmt::Display for LanguageUnknownVariantError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.0.fmt(f)
    }
}
impl std::str::FromStr for Language {
    type Err = LanguageUnknownVariantError;
    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Language::try_from(s)
    }
}
impl Language {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Language::English => "en",
            Language::Spanish => "es",
            Language::Italian => "it",
            Language::Japanese => "jp",
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["en", "es", "it", "jp"]
    }
}
impl AsRef<str> for Language {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum CapturePokemonEvents {
    #[allow(missing_docs)] // documentation missing in model
    Event(crate::model::CaptureEvent),
}
impl CapturePokemonEvents {
    #[allow(irrefutable_let_patterns)]
    /// Tries to convert the enum instance into [`Event`](crate::model::CapturePokemonEvents::Event), extracting the inner [`CaptureEvent`](crate::model::CaptureEvent).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_event(&self) -> std::result::Result<&crate::model::CaptureEvent, &Self> {
        if let CapturePokemonEvents::Event(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Event`](crate::model::CapturePokemonEvents::Event).
    pub fn is_event(&self) -> bool {
        self.as_event().is_ok()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CaptureEvent {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub captured: std::option::Option<bool>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub shiny: std::option::Option<bool>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub pokedex_update: std::option::Option<aws_smithy_types::Blob>,
}
impl CaptureEvent {
    #[allow(missing_docs)] // documentation missing in model
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn captured(&self) -> std::option::Option<bool> {
        self.captured
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn shiny(&self) -> std::option::Option<bool> {
        self.shiny
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn pokedex_update(&self) -> std::option::Option<&aws_smithy_types::Blob> {
        self.pokedex_update.as_ref()
    }
}
impl std::fmt::Debug for CaptureEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CaptureEvent");
        formatter.field("name", &self.name);
        formatter.field("captured", &self.captured);
        formatter.field("shiny", &self.shiny);
        formatter.field("pokedex_update", &self.pokedex_update);
        formatter.finish()
    }
}
/// See [`CaptureEvent`](crate::model::CaptureEvent).
pub mod capture_event {

    /// A builder for [`CaptureEvent`](crate::model::CaptureEvent).
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) captured: std::option::Option<bool>,
        pub(crate) shiny: std::option::Option<bool>,
        pub(crate) pokedex_update: std::option::Option<aws_smithy_types::Blob>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn captured(mut self, input: bool) -> Self {
            self.captured = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_captured(mut self, input: std::option::Option<bool>) -> Self {
            self.captured = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn shiny(mut self, input: bool) -> Self {
            self.shiny = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_shiny(mut self, input: std::option::Option<bool>) -> Self {
            self.shiny = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn pokedex_update(mut self, input: aws_smithy_types::Blob) -> Self {
            self.pokedex_update = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_pokedex_update(
            mut self,
            input: std::option::Option<aws_smithy_types::Blob>,
        ) -> Self {
            self.pokedex_update = input;
            self
        }
        /// Consumes the builder and constructs a [`CaptureEvent`](crate::model::CaptureEvent).
        pub fn build(self) -> crate::model::CaptureEvent {
            crate::model::CaptureEvent {
                name: self.name,
                captured: self.captured,
                shiny: self.shiny,
                pokedex_update: self.pokedex_update,
            }
        }
    }
}
impl CaptureEvent {
    /// Creates a new builder-style object to manufacture [`CaptureEvent`](crate::model::CaptureEvent).
    pub fn builder() -> crate::model::capture_event::Builder {
        crate::model::capture_event::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum AttemptCapturingPokemonEvent {
    #[allow(missing_docs)] // documentation missing in model
    Event(crate::model::CapturingEvent),
}
impl AttemptCapturingPokemonEvent {
    #[allow(irrefutable_let_patterns)]
    /// Tries to convert the enum instance into [`Event`](crate::model::AttemptCapturingPokemonEvent::Event), extracting the inner [`CapturingEvent`](crate::model::CapturingEvent).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_event(&self) -> std::result::Result<&crate::model::CapturingEvent, &Self> {
        if let AttemptCapturingPokemonEvent::Event(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Event`](crate::model::AttemptCapturingPokemonEvent::Event).
    pub fn is_event(&self) -> bool {
        self.as_event().is_ok()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CapturingEvent {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub payload: std::option::Option<crate::model::CapturingPayload>,
}
impl CapturingEvent {
    #[allow(missing_docs)] // documentation missing in model
    pub fn payload(&self) -> std::option::Option<&crate::model::CapturingPayload> {
        self.payload.as_ref()
    }
}
impl std::fmt::Debug for CapturingEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CapturingEvent");
        formatter.field("payload", &self.payload);
        formatter.finish()
    }
}
/// See [`CapturingEvent`](crate::model::CapturingEvent).
pub mod capturing_event {

    /// A builder for [`CapturingEvent`](crate::model::CapturingEvent).
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) payload: std::option::Option<crate::model::CapturingPayload>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn payload(mut self, input: crate::model::CapturingPayload) -> Self {
            self.payload = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_payload(
            mut self,
            input: std::option::Option<crate::model::CapturingPayload>,
        ) -> Self {
            self.payload = input;
            self
        }
        /// Consumes the builder and constructs a [`CapturingEvent`](crate::model::CapturingEvent).
        pub fn build(self) -> crate::model::CapturingEvent {
            crate::model::CapturingEvent {
                payload: self.payload,
            }
        }
    }
}
impl CapturingEvent {
    /// Creates a new builder-style object to manufacture [`CapturingEvent`](crate::model::CapturingEvent).
    pub fn builder() -> crate::model::capturing_event::Builder {
        crate::model::capturing_event::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CapturingPayload {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub pokeball: std::option::Option<std::string::String>,
}
impl CapturingPayload {
    #[allow(missing_docs)] // documentation missing in model
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn pokeball(&self) -> std::option::Option<&str> {
        self.pokeball.as_deref()
    }
}
impl std::fmt::Debug for CapturingPayload {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CapturingPayload");
        formatter.field("name", &self.name);
        formatter.field("pokeball", &self.pokeball);
        formatter.finish()
    }
}
/// See [`CapturingPayload`](crate::model::CapturingPayload).
pub mod capturing_payload {

    /// A builder for [`CapturingPayload`](crate::model::CapturingPayload).
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) pokeball: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn pokeball(mut self, input: impl Into<std::string::String>) -> Self {
            self.pokeball = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_pokeball(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.pokeball = input;
            self
        }
        /// Consumes the builder and constructs a [`CapturingPayload`](crate::model::CapturingPayload).
        pub fn build(self) -> crate::model::CapturingPayload {
            crate::model::CapturingPayload {
                name: self.name,
                pokeball: self.pokeball,
            }
        }
    }
}
impl CapturingPayload {
    /// Creates a new builder-style object to manufacture [`CapturingPayload`](crate::model::CapturingPayload).
    pub fn builder() -> crate::model::capturing_payload::Builder {
        crate::model::capturing_payload::Builder::default()
    }
}
